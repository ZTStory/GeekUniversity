## 浏览器工作原理总结

浏览器从输入一个 url 到最终渲染出界面总共经历了 5 个部分

### 1、HTTP 请求

通过手动拼接 Request 报文及解析 Response 报文，进一步了解 HTTP 请求的细节

在这个过程中仔细了解了 `IP、UDP、TCP（三次握手、四次挥手）`

同时也掌握了如何根据 HTTP `Request Head` 以及 `Response Head` 进行请求状态的分析

了解了常见的状态码以及其含义

着重研究了一下关于浏览器资源缓存这块内容

[HTTP 缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching)

![缓存查找流程示意图](https://static001.geekbang.org/resource/image/5f/08/5fc2f88a04ee0fc41a808f3481287408.png)

### 2、HTML 解析

这里应用了第一周开始部分接触的`有限状态机`知识，之前只了解过设计模式中的状态模式，没有接触到状态机的概念，所以感觉编程思路被打开了

通过 `有限状态机FSM` 将文本拆解为 Tag+attribute、通过 stack 将 tag 组解析为 DOM 树

整个过程基本上了解了 HTML 模板是如何被分解为一颗 DOM 树的

对以后处理树形数据结构处理有一定的思路扩展

### 3、CSS 计算

通过 css 库收集 css 规则，根据选择器将其与元素匹配，在将每个元素对应的样式根据 specificity 计算得出最终的 computedStyle，形成带有样式的 DOM 树

这一部分主要了解了选择器，选择器优先级，复杂选择器与复合选择器

利用了 css 库将 style 标签内容处理为 js object 对象，同时确定匹配关系的算法才是核心

### 4、Layout 排版

这里着重处理了 flex 布局下的排版，先将元素收进 flexLines，对每一行的子元素进行主轴与交叉轴的位置计算，最终得到带有位置属性的 DOM 树

了解过 flex 布局相关属性觉得这部分还是比较好理解的，但是属性值比较多也决定了最后的计算工作量也很大，但是由于属性相对较少，核心算法结构还是比较清晰的，需要注意的是如何根据属性计算每个 flex item 的位置

### 5、render 成图像

利用 images 库将 viewport 作为画布按照 DOM 树子元素位置进行一一绘制，得到最终的图片

这一章节用了 2 节课着实让我有些惊讶，用了`images`库完成了画布绘制工作，例子中只处理了 background-color 的属性，也让我感受到了标签是如何被一层一层画出来的。这也让我明白，层级嵌套太深是有多么的不变，会让页面层级很厚。

真实的浏览器对于 viewport 和 dom 树的完整处理会比较复杂，涉及到超出 viewport 的部分如何处理

对于浏览器渲染这块而言，还有`重排`、`重绘`、`合成`的概念，后面要做 Web 性能优化还是要好好研究一下
